---
layout:     post
title:      Creating a SHA-1 Collision
date:       2017-03-30 12:32:18
summary:    How to make two arbitrary images compute the same SHA-1 hash.
categories: Cryptography Security SHA-1
---

In Febuary of 2017, Google reasearchers announced a collision SHA-1, a function widely used in git, digital signature schemes, message authentication codes, .  Because of the way the way the collision was designed, it is possible to leverage the underlying properties of SHA-1 in order to make any two pdf documents collide at the same hash value. If you are wondering how this is done, this post is for you.


# Outline
- [Hash Functions](#Hash Functions)
    - [SHA1 and Merkle–Damgård]()
    - [Collision Attacks]()
    - [Chosen Prefix Attack]()
- [Colliding PDFs]()
- [Other Applications]()

## Hash Functions
Hash functions are deterministic functions $$H: \{0,1\}^n->\{0,1\}^{160}$$ that turn an arbitrary length message into a 160 bit digest in a way that is not reversable. Hash functions are used in data strucures like hash tables, but are also an important cryptographic primitive that support modern systems like public key infrastructure, digigal signature schemes, and even git. 

### SHA1 And Merkle–Damgård
SHA1 is built from a simple compression function $$h: \{0,1\}^{512} x s1 -> s2 $$ that takes in an input state and a block of message and outputs a new state. In order to expand the compression function to support larger messages we have to use a 'construction' SHA1 uses a construction where the compression functions are essentially chained together centepede style, were the output to the current function is the input state for the next function. This pattern is called Merkle–Damgård.

```
           /---\       /---\
IV ------> | h | ----> | h |  
           \---/       \---/
             ^          ^
             |          |              |
message ->  m1    ||    m2 || ... || (m_f||padding||message-length)

``` 

Notice that the input of any specific block is dependent solely on the output of the previous block, and a chunk of message is processed we mind as well throw it out because its not going to be used again. This construction has a whole list of major downsides, but two in particular make it possible to collide arbitrary PDF documents. 

1. Length Extension
Appending the same text to the end of the collision will result in another collision. This makes sense because the colliding digest is really just the final state of two hash functions. Note that this only works if the collision strings are the same length because of the message-length that gets put on the end of the padding. This also means that you can trim anything off the end of a collision that is shared.

$$SHA1(M_1) = SHA1(M_2)$$

$$SHA1(M_1 || S) = SHA1(M_2 || S)$$

note that...

$$SHA1(M_1) \neq SHA1(M_1 || S)$$

$$SHA1(S || M_1) \neq SHA1(S || M_2)$$


2. Prefix Attacks
More on this later, but basically this construction allows us to create a prefix and then generate a collision from the state generated by this prefix.


## Collision Attacks
One of the 




### Shattered

[shattered.io](https://shattered.io/) provides two visually different PDFs that compute to the same sha1sum

general rule for finding hash collisions:
if the digest is 160 bits long, finding any two digests that have the same value takes $$2^{80}$$ ($$2^{79}$$ on average) operations (birthday problem) 
finding a specific collision will take $$2^{160}$$ ($$2^{159}$$) operations 

*identical-prefix collision attack* is given the flexibility to choose a prefix, and know the length of the collision beforehand, much more powerful than finding any old collision but not quite as powerful as finding a collision for a specific hash

In order to generate the collision the researchers used prefix attack whrere they generated two bitstrings of the form 

$$SHA1(P || m^1_1 || m^1_2 || S) == SHA1(P || m^2_1 || m^2_2 || S)$$

$$P$$ was a premeditated value chosen by the researchers 
$$M^1_1 and M^2_1$$ *near collision block pairs*




``` bash
$ sha1sum shattered-1.pdf 
38762cf7f55934b34d179ae6a4c80cadccbb7f0a  shattered-1.pdf
$ sha1sum shattered-2.pdf
38762cf7f55934b34d179ae6a4c80cadccbb7f0a  shattered-2.pdf
```

when we run a diff on the two PDFs theres a surprisingly small amount of data that is actually different, definately not different enough to account for the visual difference you see in the two PDFs. The trick of this attack lies in the PDF format. 

![shattered-1-diff](/images/shattered-1-diff.png){:text-align="center"}
![shattered-2-diff](/images/shattered-2-diff.png){:text-align="center"}



```
00000000: 2550 4446 2d31 2e33 0a25 e2e3 cfd3 0a0a  %PDF-1.3.%.....
00000010: 0a31 2030 206f 626a 0a3c 3c2f 5769 6474  .1 0 obj.<</Widt
00000020: 6820 3220 3020 522f 4865 6967 6874 2033  h 2 0 R/Height 3
00000030: 2030 2052 2f54 7970 6520 3420 3020 522f   0 R/Type 4 0 R/
00000040: 5375 6274 7970 6520 3520 3020 522f 4669  Subtype 5 0 R/Fi
00000050: 6c74 6572 2036 2030 2052 2f43 6f6c 6f72  lter 6 0 R/Color
00000060: 5370 6163 6520 3720 3020 522f 4c65 6e67  Space 7 0 R/Leng
00000070: 7468 2038 2030 2052 2f42 6974 7350 6572  th 8 0 R/BitsPer
00000080: 436f 6d70 6f6e 656e 7420 383e 3e0a 7374  Component 8>>.st
00000090: 7265 616d 0aff d8ff fe00 2453 4841 2d31  ream......$SHA-1
000000a0: 2069 7320 6465 6164 2121 2121 2185 2fec   is dead!!!!!./.
000000b0: 0923 3975 9c39 b1a1 c63c 4c97 e1ff fe01  .#9u.9...<L.....
```

```
PDF-1.3
...
1 0 obj
    <<
        /Width 2 0 R
        /Height 3 0 R
        /Type 4 0 R
        /Subtype 5 0 R
        /Filter 6 0 R
        /ColorSpace 7 0 R
        /Length 8 0 R 
        /BitsPerComponent 8
    >>

    stream ....$SHA-1 is dead!!!!!
    ./#9u.0...<L....

    random junk


    endstream
endobj
```

start of jpeg 
FFD8

start of comment
FFFE

end of jpeg
FFD9

$$\mathcal{L}(t) = l_0 \cdot \lambda^t,$$

$$
\begin{align*}
  & \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
  = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
  & (x_1, \ldots, x_n) \left( \begin{array}{ccc}
      \phi(e_1, e_1) & \cdots & \phi(e_1, e_n) \\
      \vdots & \ddots & \vdots \\
      \phi(e_n, e_1) & \cdots & \phi(e_n, e_n)
    \end{array} \right)
  \left( \begin{array}{c}
      y_1 \\
      \vdots \\
      y_n
    \end{array} \right)
\end{align*}
$$

hi $$x$$ tyhere